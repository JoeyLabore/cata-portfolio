<!DOCTYPE html>
<html lang="en" class="dark">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="icon" type="image/jpg" href="assets/favicon.jpg" />
  <title>Archive - Laura Ledesna</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Syne:wght@400;500;600;700;800&family=Inter:wght@600&family=Roboto+Flex:opsz,wght@8..144,100..1000&display=swap" rel="stylesheet">
  <script src="https://unpkg.com/@phosphor-icons/web"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          fontFamily: {
            'syne': ['Syne', 'sans-serif'],
            'inter': ['Inter', 'sans-serif'],
          },
          colors: {
            'primary': '#ffffff',
            'inverse': '#cccccc',
            'paragraph': '#0d0d0d',
          },
          spacing: {
            'none': '0',
            'xxs': '4px',
            'xs': '8px',
            's': '16px',
            'm': '24px',
            'lg': '32px',
            'xl': '48px',
            '2xl': '64px',
            '3xl': '80px',
          },
        }
      }
    }
  </script>
  <style>
    /* Variable Proximity headline uses Roboto Flex variable font (match index) */
    .vp-roboto-flex { font-family: "Roboto Flex", sans-serif !important; }
    html, body {
      margin: 0;
      padding: 0;
      overflow-x: hidden; /* avoid accidental horizontal scroll */
      overscroll-behavior-y: none;
      overscroll-behavior-x: none;
    }
    .dark {
      --surface-primary: #000000;
      --surface-inverse: #333333;
      --surface-secondary: #1a1a1a;
      --surface-tertiary: #333333;
      --typography-heading: #ffffff;
      --typography-paragraph: #ffffff;
      --stroke-border: #333333;
      --media-icon: #ffffff;
    }
    .bg-theme-primary { background-color: var(--surface-primary); }
    .bg-theme-inverse { background-color: var(--surface-inverse); }
    .text-theme-heading { color: var(--typography-heading); }
    .border-theme { border-color: var(--stroke-border); }
    /* Icon color handling (match index) */
    .icon-theme {
      filter: brightness(0) saturate(100%);
      color: var(--media-icon);
    }
    .dark .icon-theme {
      filter: brightness(0) saturate(100%) invert(1);
    }
    /* Force black icons inside light footers even when page is dark */
    footer.light .icon-theme {
      filter: brightness(0) saturate(100%) !important;
      color: #000 !important;
    }
    /* Light mode: Book a call button (starts black, lighten on hover/active) */
    .light .book-call { background: #000000 !important; color: #ffffff !important; }
    .light .book-call:hover { background: #0d0d0d !important; }
    .light .book-call:active { background: #1a1a1a !important; }

    /* Menu Item States (match index) */
    .menu-item {
      background-color: var(--surface-primary);
      cursor: pointer;
      transition: background-color 0.2s ease;
      border-color: var(--stroke-border);
    }
    @media (min-width: 601px) {
      .menu-item:hover { background-color: var(--surface-secondary); }
    }
    .menu-item:active { background-color: var(--surface-tertiary); }

    /* Ensure light footers render on white backgrounds like index */
    footer.light { background-color: #ffffff !important; }
    footer.footer-figma { background-color: #ffffff !important; }
    /* Force footer text colors to black to match index */
    footer.light .text-theme-heading,
    footer.light .text-theme-paragraph { color: #000000 !important; }
    footer.light .footer-link::after { background-color: #000000 !important; }

    /* Back-to-top label underline (match index) */
    .scroll-text {
      position: relative;
      cursor: pointer;
    }
    .scroll-text::after {
      content: '';
      position: absolute;
      width: 100%;
      height: 1px;
      bottom: -4px;
      left: 0;
      background-color: var(--typography-heading);
      transform: scaleX(0);
      transition: transform 0.2s ease;
    }
    .scroll-text:hover::after { transform: scaleX(1); }
    .scroll-text:active::after { height: 4px; }
    footer.light .scroll-text::after { background-color: #000000 !important; }

    /* Footer links: mimic Back to top hover/active underline */
    .footer-link {
      position: relative;
      cursor: pointer;
      text-decoration: none !important;
      display: inline-block;
      align-self: flex-start;
      width: auto;
    }
    .footer-link::after {
      content: '';
      position: absolute;
      width: 100%;
      height: 1px;
      bottom: -4px;
      left: 0;
      background-color: var(--typography-heading);
      transform: scaleX(0);
      transition: transform 0.2s ease;
    }
    .footer-link:hover::after { transform: scaleX(1); }
    .footer-link:active::after { height: 4px; }

    /* FAB: hidden by default, revealed after initial animations */
    .fab-hidden { opacity: 0; transform: translateY(16px); }
    .fab-show { opacity: 1; transform: translateY(0); transition: opacity 0.4s cubic-bezier(0.16, 1, 0.3, 1), transform 0.4s cubic-bezier(0.16, 1, 0.3, 1); }
    /* FAB hide when footer visible */
    .fab-hide { opacity: 0; transform: translateY(16px); transition: opacity 0.25s ease, transform 0.25s ease; pointer-events: none; }

    /* Footer headline size for <= 900px */
    @media (max-width: 900px) {
      .footer-headline { font-size: 32px !important; }
      footer.footer-figma { padding-top: 32px !important; padding-bottom: 32px !important; }
      footer.footer-figma .gap-24 { gap: 3rem !important; }
      footer.footer-figma .gap-32 { gap: 1.5rem !important; }
      #vp-footer-container > .grid { padding-top: 40px !important; }
    }

    /* Footer buttons: stack vertically and fill width on very small screens */
    @media (max-width: 450px) {
      .footer-buttons {
        flex-direction: column !important;
        width: 100% !important;
        gap: 2rem !important;
      }
      .footer-buttons > a {
        width: 100% !important;
        text-align: center !important;
      }
    }

    /* Hide Back to top button on small screens */
    @media (max-width: 750px) {
      footer .scroll-button { display: none !important; }
    }

    /* Full-screen menu overlay */
    .menu-overlay {
      position: fixed;
      top: 82px; /* keep header visible */
      left: 0; right: 0; bottom: 0;
      background: var(--surface-primary);
      z-index: 100;
      display: flex; /* keep in flow for transitions */
      align-items: flex-start; /* align to top */
      justify-content: flex-start; /* start at top-left */
      border-top: 1px solid var(--stroke-border); /* border below header */
      /* Animation base */
      opacity: 0;
      transform: translateY(-8px);
      transition: opacity 200ms ease, transform 200ms ease;
      pointer-events: none;
    }
    .menu-overlay.open { 
      opacity: 1; 
      transform: none; 
      pointer-events: auto;
    }
    .menu-overlay .overlay-content {
      display: flex;
      flex-direction: column;
      gap: 0; /* no vertical gap, borders divide items */
      width: 100%;
      max-width: none; /* full width */
      padding: 0; /* borders reach edges */
      /* Staggered content entrance */
      opacity: 0;
      transform: translateY(8px);
      transition: opacity 220ms ease 60ms, transform 220ms ease 60ms;
    }
    .menu-overlay.open .overlay-content { opacity: 1; transform: none; }
    .menu-overlay a {
      display: flex;
      align-items: center;
      justify-content: flex-start;
      height: 80px;
      padding: 0 16px; /* 16px gutters */
      border-bottom: 1px solid var(--stroke-border);
    }
    .menu-overlay a:last-child { border-bottom: 0; }
    /* On mobile, keep the bottom border on the last item */
    @media (max-width: 700px) {
      .menu-overlay a {
        border-left: 1px solid var(--stroke-border);
        border-right: 1px solid var(--stroke-border);
      }
      .menu-overlay a:last-child { border-bottom: 1px solid var(--stroke-border); }
    }
    @media (prefers-reduced-motion: reduce) {
      .menu-overlay { transition: none; }
      .menu-overlay .overlay-content { transition: none; }
    }

    /* Navigation Responsive Styles */
    .mobile-menu { display: none !important; }
    @media (max-width: 700px) {
      .desktop-menu { display: none !important; }
      .mobile-menu { display: flex !important; padding-left: 16px !important; padding-right: 0 !important; }
    }
    /* Enforce 16px gutters on mobile/tablet <= 900px */
    @media (max-width: 900px) {
      .px-8 { padding-left: 16px !important; padding-right: 16px !important; }
      .p-8 { padding-left: 16px !important; padding-right: 16px !important; }
      .pl-8 { padding-left: 16px !important; }
      .pr-8 { padding-right: 16px !important; }
      /* Override mobile nav right padding to 16px (previously 0 under 700px) */
      .mobile-menu { padding-right: 16px !important; }
    }
  </style>
  <!-- React + ReactDOM UMD -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <!-- Babel for JSX in-browser (dev only) -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body class="bg-theme-primary">
  <div class="min-h-screen bg-theme-inverse p-[1px] flex flex-col gap-[1px] mx-auto max-w-[1920px] w-full">
    <!-- Navigation -->
    <!-- Desktop Navigation -->
    <nav class="desktop-menu bg-theme-primary h-[82px] flex items-center justify-between pl-8 animate-slide-up nav-animation">
      <a href="index.html" class="font-syne font-medium text-[16px] leading-[1.6] text-theme-heading">Laura Ledesna</a>
      <div class="flex h-full">
        <a href="mailto:iamlauraledesna@gmail.com" class="menu-item h-[82px] w-[167px] flex items-center px-4 border-l border-theme">
          <span class="font-syne font-normal text-[16px] leading-[1.6] text-theme-heading">Email</span>
        </a>
        <a href="archive.html" class="menu-item h-[82px] w-[167px] flex items-center px-4 border-l border-theme">
          <span class="font-syne font-normal text-[16px] leading-[1.6] text-theme-heading">Archive</span>
        </a>
        <a href="assets/cv-laura-ledesna.pdf" download target="_blank" class="menu-item h-[82px] w-[167px] flex items-center px-4 border-l border-theme">
          <span class="font-syne font-normal text-[16px] leading-[1.6] text-theme-heading">Resume</span>
        </a>
      </div>
    </nav>

    <!-- Mobile Navigation -->
    <nav class="mobile-menu bg-theme-primary h-[82px] flex items-center justify-between pl-4 pr-0 animate-slide-up nav-animation">
      <a href="index.html" class="font-syne font-medium text-[16px] leading-[1.6] text-theme-heading whitespace-pre">Laura Ledesna</a>
      <button id="mobile-menu-toggle" class="bg-theme-primary flex items-center justify-center size-[82px] relative shrink-0 border-l border-theme" aria-expanded="false" aria-controls="menu-overlay" aria-label="Open menu">
        <div class="relative shrink-0 size-8">
          <div class="absolute inset-[12.5%] icon-menu">
            <img src="assets/List.svg" alt="Menu" class="block max-w-none size-full icon-theme">
          </div>
          <div class="absolute inset-[12.5%] icon-close" style="display:none;">
            <svg viewBox="0 0 256 256" class="block max-w-none size-full icon-theme" aria-hidden="true" focusable="false">
              <line x1="200" y1="56" x2="56" y2="200" stroke="currentColor" stroke-width="24" stroke-linecap="round" stroke-linejoin="round"/>
              <line x1="56" y1="56" x2="200" y2="200" stroke="currentColor" stroke-width="24" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </div>
        </div>
      </button>
    </nav>

    <!-- Full-screen Menu Overlay -->
    <div id="menu-overlay" class="menu-overlay" aria-hidden="true">
      <div class="overlay-content">
        <a href="index.html" class="menu-item">
          <span class="font-syne font-normal text-[16px] leading-[1.6] text-theme-heading">Home</span>
        </a>
        <a href="archive.html" class="menu-item">
          <span class="font-syne font-normal text-[16px] leading-[1.6] text-theme-heading">Archive</span>
        </a>
        <a href="mailto:iamlauraledesna@gmail.com" class="menu-item">
          <span class="font-syne font-normal text-[16px] leading-[1.6] text-theme-heading">Email</span>
        </a>
        <a href="assets/cv-laura-ledesna.pdf" download target="_blank" class="menu-item">
          <span class="font-syne font-normal text-[16px] leading-[1.6] text-theme-heading">Resume</span>
        </a>
      </div>
    </div>

    <script>
      // Mobile full-screen overlay menu (active only when <=600px)
      (function(){
        const toggle = document.getElementById('mobile-menu-toggle');
        const overlay = document.getElementById('menu-overlay');
        if (!toggle || !overlay) return;
        const mql = window.matchMedia('(max-width: 600px)');

        let __overlayScrollY = 0;
        function lockScroll(){
          __overlayScrollY = window.scrollY || window.pageYOffset || 0;
          document.documentElement.style.overflow = 'hidden';
          document.body.style.position = 'fixed';
          document.body.style.top = `-${__overlayScrollY}px`;
          document.body.style.left = '0';
          document.body.style.right = '0';
          document.body.style.width = '100%';
        }
        function unlockScroll(){
          document.documentElement.style.overflow = '';
          document.body.style.position = '';
          document.body.style.top = '';
          document.body.style.left = '';
          document.body.style.right = '';
          document.body.style.width = '';
          window.scrollTo(0, __overlayScrollY || 0);
        }

        function openOverlay(){
          overlay.classList.add('open');
          overlay.setAttribute('aria-hidden','false');
          toggle.setAttribute('aria-expanded','true');
          document.addEventListener('click', onDoc, true);
          document.addEventListener('keydown', onKey, true);
          lockScroll();
          // swap icons and label
          const menuIco = toggle.querySelector('.icon-menu');
          const closeIco = toggle.querySelector('.icon-close');
          if (menuIco) menuIco.style.display = 'none';
          if (closeIco) closeIco.style.display = 'block';
          toggle.setAttribute('aria-label','Close menu');
        }
        function closeOverlay(){
          overlay.classList.remove('open');
          overlay.setAttribute('aria-hidden','true');
          toggle.setAttribute('aria-expanded','false');
          document.removeEventListener('click', onDoc, true);
          document.removeEventListener('keydown', onKey, true);
          unlockScroll();
          // swap icons and label back
          const menuIco = toggle.querySelector('.icon-menu');
          const closeIco = toggle.querySelector('.icon-close');
          if (menuIco) menuIco.style.display = 'block';
          if (closeIco) closeIco.style.display = 'none';
          toggle.setAttribute('aria-label','Open menu');
        }
        function onToggle(e){
          e.stopPropagation();
          if (!mql.matches) return;
          const open = overlay.classList.contains('open');
          open ? closeOverlay() : openOverlay();
        }
        function onDoc(e){
          // Close if clicking outside inner content (background tap)
          const content = overlay.querySelector('.overlay-content');
          if (!content.contains(e.target) && e.target !== toggle && !toggle.contains(e.target)) {
            closeOverlay();
          }
        }
        function onKey(e){ if (e.key === 'Escape') closeOverlay(); }
        function handle(){ closeOverlay(); if (mql.matches){ toggle.addEventListener('click', onToggle); } else { toggle.removeEventListener('click', onToggle); } }
        handle();
        mql.addEventListener ? mql.addEventListener('change', handle) : mql.addListener(handle);
      })();

    </script>
    
    <script>
      // Reveal FAB after initial delay; hide when footer visible (match index behavior)
      window.addEventListener('DOMContentLoaded', function () {
        const fab = document.getElementById('home-fab');
        if (!fab) return;
        const reveal = () => { fab.classList.add('fab-show'); fab.classList.remove('fab-hidden'); };
        // Reveal after a short delay (no case-study animation on archive)
        setTimeout(reveal, 500);

        // Hide FAB when footer enters viewport
        const footer = document.querySelector('footer.footer-figma');
        if (footer && 'IntersectionObserver' in window) {
          const io = new IntersectionObserver((entries) => {
            for (const entry of entries) {
              if (entry.isIntersecting) {
                fab.classList.add('fab-hide');
              } else {
                if (fab.classList.contains('fab-show')) {
                  fab.classList.remove('fab-hide');
                }
              }
            }
          }, { threshold: 0.1 });
          io.observe(footer);
        }
      });
    </script>
    
    <script>
      // Match index: reset scroll to top on load and when returning via bfcache
      window.addEventListener('load', function () {
        window.scrollTo(0, 0);
      });
      window.addEventListener('pageshow', function (e) {
        if (e.persisted) {
          window.scrollTo(0, 0);
        }
      });
    </script>

    <!-- App mount -->
    <section class="bg-theme-primary relative" style="height: calc(100vh - 83px)">
      <div id="root" class="w-full h-full"></div>
    </section>

        <!-- Home FAB: Book a call (matches index) -->
        <a
          id="home-fab"
          href="https://calendly.com/iamlauraledesna/new-meeting?month=2025-08"
          target="_blank"
          rel="noopener noreferrer"
          aria-label="Book a call"
          class="fixed z-[1000] bg-white text-black box-border flex gap-2.5 items-center justify-center pl-1 pr-2 py-1 whitespace-nowrap group cursor-pointer transition-all duration-150 ease-out fab-hidden"
          style="right: calc(16px + env(safe-area-inset-right)); bottom: calc(16px + env(safe-area-inset-bottom));"
        >
          <span class="bg-center bg-cover bg-no-repeat h-[35.243px] w-[37px] shrink-0" style="background-image: url('assets/profile-img.jpeg');"></span>
          <span class="font-syne font-bold not-italic text-[16px] leading-[1.6] pr-0 group-hover:pr-0">Book a call</span>
          <span class="relative shrink-0 h-6 w-0 overflow-hidden opacity-0 translate-x-2 transition-all duration-150 ease-out group-hover:opacity-100 group-hover:translate-x-0 group-hover:w-6">
            <i class="ph ph-arrow-up-right block w-6 h-6 text-black text-[24px] leading-none" aria-hidden="true"></i>
          </span>
        </a>

        <!-- Footer -->
        <footer class="light bg-theme-primary px-8 py-12 animate-slide-up footer-figma" style="animation-delay: 1.2s;">
            <div id="vp-footer-container" class="w-full mx-auto flex flex-col lg:flex-row gap-32 items-start justify-between">
                <!-- Left: Title + Buttons -->
                <div class="basis-0 grow flex flex-col gap-12">
                    <h2 id="vp-footer-headline" class="vp-roboto-flex font-syne font-medium text-[48px] leading-[1.4] text-theme-heading footer-headline scroll-animate" data-scroll>
                        Every great experience starts with a conversation.
                    </h2>
                    <div class="flex gap-8 footer-buttons scroll-animate" data-scroll>
                        <a href="https://calendly.com/iamlauraledesna/new-meeting?month=2025-08" target="_blank" rel="noopener noreferrer" class="book-call bg-white hover:bg-[#f2f2f2] active:bg-[#e6e6e6] transition-colors duration-150 text-black px-6 py-4 font-syne font-medium not-italic text-[16px] leading-[1.6] whitespace-nowrap" aria-label="Book a call">
                            Book a call
                        </a>
                    </div>
                </div>

                <!-- Right: Link columns -->
                <div class="basis-0 grow grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-16 w-full " style="
                padding-top: 16px;
            ">
                    <!-- Navigation -->
                    <div class="flex flex-col gap-4 scroll-animate" data-scroll>
                        <div class="font-syne font-bold text-[16px] leading-[1.6] text-theme-heading">Navigation</div>
                        <nav class="flex flex-col gap-4 font-syne font-normal text-[16px] leading-[1.6] text-theme-paragraph">
                            <a href="index.html" class="footer-link">Home</a>
                            <a href="ai-solution-case-study.html" class="footer-link">AI Solution</a>
                            <a href="nestbank-case-study.html" class="footer-link">Nestbank</a>
                            <a href="medigo-case-study.html" class="footer-link">Medigo</a>
                        </nav>
                    </div>

                    <!-- More From Me -->
                    <div class="flex flex-col gap-4 scroll-animate" data-scroll>
                        <div class="font-syne font-bold text-[16px] leading-[1.6] text-theme-heading">More From Me</div>
                        <div class="flex flex-col gap-4 font-syne font-normal text-[16px] leading-[1.6] text-theme-paragraph">
                            <a href="https://medium.com/@iamlauraledesna" target="_blank" rel="noopener noreferrer" class="footer-link">Medium Articles</a>
                            <a href="assets/cv-laura-ledesna.pdf" download target="_blank" rel="noopener noreferrer" class="footer-link">Resume</a>
                        </div>
                    </div>

                    <!-- Contact Me -->
                    <div class="flex flex-col gap-4 scroll-animate" data-scroll>
                        <div class="font-syne font-bold text-[16px] leading-[1.6] text-theme-heading">Contact Me</div>
                        <div class="flex flex-col gap-4 font-syne font-normal text-[16px] leading-[1.6] text-theme-paragraph">
                            <a href="https://calendly.com/iamlauraledesna/new-meeting?month=2025-08" target="_blank" rel="noopener noreferrer" class="footer-link">Book a Call</a>
                            <a href="mailto:iamlauraledesna@gmail.com" class="footer-link">Email</a>
                            <a href="https://www.linkedin.com/in/iamlauraledesna/" target="_blank" rel="noopener noreferrer" class="footer-link">LinkedIn</a>
                        </div>
                    </div>
                </div>
            </div>

        </footer>
        <!-- Case-study footer -->
        <footer class="light bg-theme-primary px-8 py-6 flex items-center justify-between animate-slide-up" style="animation-delay: 1.2s;">
            <div class="font-syne font-normal text-[16px] leading-[1.6] text-theme-heading">
                <a href="index.html" class="no-underline text-theme-heading">Laura Ledesna • ©2025</a>
            </div>
            <button onclick="window.scrollTo({top: 0, behavior: 'smooth'})" class="scroll-button flex items-center gap-2">
                <span class="scroll-text font-syne font-normal text-[16px] leading-[1.6] text-theme-heading">Back to top</span>
                <div class="relative shrink-0 size-4">
                    <div class="absolute inset-[12.5%]">
                        <img src="assets/ArrowUp.svg" alt="Arrow Up" class="block max-w-none size-full icon-theme">
                    </div>
                </div>
            </button>
        </footer>

  </div>

  <script type="text/babel">
    const { useEffect, useMemo, useRef, useCallback } = React;

    const DEFAULT_IMAGES = [
      { src: 'assets/archive/media-1.png', alt: 'Archive image 1' },
      { src: 'assets/archive/media-2.png', alt: 'Archive image 2' },
      { src: 'assets/archive/media-3.jpg', alt: 'Archive image 3' },
      { src: 'assets/archive/media-4.png', alt: 'Archive image 4' },
      { src: 'assets/archive/media-5.png', alt: 'Archive image 5' },
      { src: 'assets/archive/media-6.png', alt: 'Archive image 6' },
      { src: 'assets/archive/media-7.png', alt: 'Archive image 7' },
      { src: 'assets/archive/media-8.png', alt: 'Archive image 8' },
      { src: 'assets/archive/media-9.png', alt: 'Archive image 9' },
      { src: 'assets/archive/media-10.png', alt: 'Archive image 10' },
      { src: 'assets/archive/media-11.jpg', alt: 'Archive image 11' },
      { src: 'assets/archive/media-12.png', alt: 'Archive image 12' },
      { src: 'assets/archive/media-13.jpg', alt: 'Archive image 13' },
      { src: 'assets/archive/media-14.jpg', alt: 'Archive image 14' },
      { src: 'assets/archive/media-15.png', alt: 'Archive image 15' },
      { src: 'assets/archive/media-16.png', alt: 'Archive image 16' },
      { src: 'assets/archive/media-17.png', alt: 'Archive image 17' },
      { src: 'assets/archive/media-18.png', alt: 'Archive image 18' },
      { src: 'assets/archive/media-19.png', alt: 'Archive image 19' },
      { src: 'assets/archive/media-20.jpg', alt: 'Archive image 20' },
      { src: 'assets/archive/media-21.png', alt: 'Archive image 21' },
    ];

    const DEFAULTS = { maxVerticalRotationDeg: 5, dragSensitivity: 20, enlargeTransitionMs: 300, segments: 35 };
    const clamp = (v, min, max) => Math.min(Math.max(v, min), max);
    const normalizeAngle = d => ((d % 360) + 360) % 360;
    const wrapAngleSigned = deg => { const a = (((deg + 180) % 360) + 360) % 360; return a - 180; };
    const getDataNumber = (el, name, fallback) => { const attr = el.dataset[name] ?? el.getAttribute(`data-${name}`); const n = attr == null ? NaN : parseFloat(attr); return Number.isFinite(n) ? n : fallback; };

    function buildItems(pool, seg) {
      const xCols = Array.from({ length: seg }, (_, i) => -37 + i * 2);
      const evenYs = [-4, -2, 0, 2, 4];
      const oddYs = [-3, -1, 1, 3, 5];
      const coords = xCols.flatMap((x, c) => { const ys = c % 2 === 0 ? evenYs : oddYs; return ys.map(y => ({ x, y, sizeX: 2, sizeY: 2 })); });
      const totalSlots = coords.length;
      if (pool.length === 0) return coords.map(c => ({ ...c, src: '', alt: '' }));
      const normalizedImages = pool.map(image => typeof image === 'string' ? ({ src: image, alt: '' }) : ({ src: image.src || '', alt: image.alt || '' }));
      const used = Array.from({ length: totalSlots }, (_, i) => normalizedImages[i % normalizedImages.length]);
      for (let i = 1; i < used.length; i++) { if (used[i].src === used[i-1].src) { for (let j = i+1; j < used.length; j++) { if (used[j].src !== used[i].src) { const t = used[i]; used[i]=used[j]; used[j]=t; break; } } } }
      return coords.map((c,i)=>({ ...c, src: used[i].src, alt: used[i].alt }));
    }

    function computeItemBaseRotation(offsetX, offsetY, sizeX, sizeY, segments) {
      const unit = 360 / segments / 2;
      const rotateY = unit * (offsetX + (sizeX - 1) / 2);
      const rotateX = unit * (offsetY - (sizeY - 1) / 2);
      return { rotateX, rotateY };
    }

    function DomeGallery({
      images = DEFAULT_IMAGES,
      fit = 0.5,
      fitBasis = 'auto',
      minRadius = 600,
      maxRadius = Infinity,
      padFactor = 0.25,
      overlayBlurColor = '#060010',
      maxVerticalRotationDeg = DEFAULTS.maxVerticalRotationDeg,
      dragSensitivity = DEFAULTS.dragSensitivity,
      enlargeTransitionMs = DEFAULTS.enlargeTransitionMs,
      segments = DEFAULTS.segments,
      dragDampening = 2,
      openedImageWidth = null,
      openedImageHeight = null,
      imageBorderRadius = '30px',
      openedImageBorderRadius = '30px',
      grayscale = true
    }) {
      const rootRef = useRef(null);
      const mainRef = useRef(null);
      const sphereRef = useRef(null);
      const frameRef = useRef(null);
      const viewerRef = useRef(null);
      const scrimRef = useRef(null);
      const focusedElRef = useRef(null);
      const originalTilePositionRef = useRef(null);

      const rotationRef = useRef({ x: 0, y: 0 });
      const startRotRef = useRef({ x: 0, y: 0 });
      const startPosRef = useRef(null);
      const draggingRef = useRef(false);
      const cancelTapRef = useRef(false);
      const movedRef = useRef(false);
      const inertiaRAF = useRef(null);
      const pointerTypeRef = useRef('mouse');
      const tapTargetRef = useRef(null);
      const openingRef = useRef(false);
      const openStartedAtRef = useRef(0);
      const lastDragEndAt = useRef(0);

      const scrollLockedRef = useRef(false);
      const lockScroll = useCallback(() => {
        if (scrollLockedRef.current) return;
        scrollLockedRef.current = true;
        document.body.classList.add('dg-scroll-lock');
      }, []);
      const unlockScroll = useCallback(() => {
        if (!scrollLockedRef.current) return;
        if (rootRef.current?.getAttribute('data-enlarging') === 'true') return;
        scrollLockedRef.current = false;
        document.body.classList.remove('dg-scroll-lock');
      }, []);

      const items = useMemo(() => buildItems(images, segments), [images, segments]);
      const applyTransform = (xDeg, yDeg) => {
        const el = sphereRef.current;
        if (el) el.style.transform = `translateZ(calc(var(--radius) * -1)) rotateX(${xDeg}deg) rotateY(${yDeg}deg)`;
      };
      const lockedRadiusRef = useRef(null);

      useEffect(() => {
        const root = rootRef.current; if (!root) return;
        const ro = new ResizeObserver(entries => {
          const cr = entries[0].contentRect; const w = Math.max(1, cr.width), h = Math.max(1, cr.height);
          const minDim = Math.min(w, h), maxDim = Math.max(w, h), aspect = w / h;
          let basis; switch (fitBasis) {
            case 'min': basis = minDim; break; case 'max': basis = maxDim; break; case 'width': basis = w; break; case 'height': basis = h; break; default: basis = aspect >= 1.3 ? w : minDim;
          }
          let radius = basis * fit; const heightGuard = h * 1.35; radius = Math.min(radius, heightGuard); radius = clamp(radius, minRadius, maxRadius);
          lockedRadiusRef.current = Math.round(radius);
          const viewerPad = Math.max(8, Math.round(minDim * padFactor));
          root.style.setProperty('--radius', `${lockedRadiusRef.current}px`);
          root.style.setProperty('--viewer-pad', `${viewerPad}px`);
          root.style.setProperty('--overlay-blur-color', overlayBlurColor);
          root.style.setProperty('--tile-radius', imageBorderRadius);
          root.style.setProperty('--enlarge-radius', openedImageBorderRadius);
          root.style.setProperty('--image-filter', grayscale ? 'grayscale(1)' : 'none');
          applyTransform(rotationRef.current.x, rotationRef.current.y);
          const enlargedOverlay = viewerRef.current?.querySelector('.enlarge');
          if (enlargedOverlay && frameRef.current && mainRef.current) {
            const frameR = frameRef.current.getBoundingClientRect();
            const mainR = mainRef.current.getBoundingClientRect();
            const hasCustomSize = openedImageWidth && openedImageHeight;
            if (hasCustomSize) {
              const tempDiv = document.createElement('div');
              tempDiv.style.cssText = `position: absolute; width: ${openedImageWidth}; height: ${openedImageHeight}; visibility: hidden;`;
              document.body.appendChild(tempDiv);
              const tempRect = tempDiv.getBoundingClientRect();
              document.body.removeChild(tempDiv);
              const centeredLeft = frameR.left - mainR.left + (frameR.width - tempRect.width) / 2;
              const centeredTop = frameR.top - mainR.top + (frameR.height - tempRect.height) / 2;
              enlargedOverlay.style.left = `${centeredLeft}px`;
              enlargedOverlay.style.top = `${centeredTop}px`;
            } else {
              enlargedOverlay.style.left = `${frameR.left - mainR.left}px`;
              enlargedOverlay.style.top = `${frameR.top - mainR.top}px`;
              enlargedOverlay.style.width = `${frameR.width}px`;
              enlargedOverlay.style.height = `${frameR.height}px`;
            }
          }
        });
        ro.observe(root);
        return () => ro.disconnect();
      }, [fit, fitBasis, minRadius, maxRadius, padFactor, overlayBlurColor, grayscale, imageBorderRadius, openedImageBorderRadius, openedImageWidth, openedImageHeight]);

      useEffect(() => { applyTransform(rotationRef.current.x, rotationRef.current.y); }, []);

      const stopInertia = useCallback(() => { if (inertiaRAF.current) { cancelAnimationFrame(inertiaRAF.current); inertiaRAF.current = null; } }, []);
      const startInertia = useCallback((vx, vy) => {
        const MAX_V = 1.4; let vX = clamp(vx, -MAX_V, MAX_V) * 80; let vY = clamp(vy, -MAX_V, MAX_V) * 80; let frames = 0;
        const d = clamp(dragDampening ?? 0.6, 0, 1); const frictionMul = 0.94 + 0.055 * d; const stopThreshold = 0.015 - 0.01 * d; const maxFrames = Math.round(90 + 270 * d);
        const step = () => {
          vX *= frictionMul; vY *= frictionMul;
          if (Math.abs(vX) < stopThreshold && Math.abs(vY) < stopThreshold) { inertiaRAF.current = null; return; }
          if (++frames > maxFrames) { inertiaRAF.current = null; return; }
          const nextX = clamp(rotationRef.current.x - vY / 200, -maxVerticalRotationDeg, maxVerticalRotationDeg);
          const nextY = wrapAngleSigned(rotationRef.current.y + vX / 200);
          rotationRef.current = { x: nextX, y: nextY }; applyTransform(nextX, nextY); inertiaRAF.current = requestAnimationFrame(step);
        };
        stopInertia(); inertiaRAF.current = requestAnimationFrame(step);
      }, [dragDampening, maxVerticalRotationDeg, stopInertia]);

      // Native pointer gesture handling (no external dependency)
      useEffect(() => {
        const el = mainRef.current; if (!el) return;
        const onPointerDown = (event) => {
          stopInertia();
          pointerTypeRef.current = event.pointerType || 'mouse';
          if (pointerTypeRef.current === 'touch') { event.preventDefault(); lockScroll(); }
          draggingRef.current = true; cancelTapRef.current = false; movedRef.current = false;
          startRotRef.current = { ...rotationRef.current };
          startPosRef.current = { x: event.clientX, y: event.clientY, t: performance.now() };
          const potential = event.target.closest?.('.item__image');
          tapTargetRef.current = potential || null;
          window.addEventListener('pointermove', onPointerMove, { passive: false });
          window.addEventListener('pointerup', onPointerUp, { passive: false, once: true });
        };
        let lastMove = { x: 0, y: 0, t: 0 };
        const onPointerMove = (event) => {
          if (!draggingRef.current || !startPosRef.current || focusedElRef.current) return;
          if (pointerTypeRef.current === 'touch') event.preventDefault();
          const dxTotal = event.clientX - startPosRef.current.x;
          const dyTotal = event.clientY - startPosRef.current.y;
          if (!movedRef.current) { const dist2 = dxTotal*dxTotal + dyTotal*dyTotal; if (dist2 > 16) movedRef.current = true; }
          const nextX = clamp(startRotRef.current.x - dyTotal / dragSensitivity, -maxVerticalRotationDeg, maxVerticalRotationDeg);
          const nextY = startRotRef.current.y + dxTotal / dragSensitivity;
          const cur = rotationRef.current; if (cur.x !== nextX || cur.y !== nextY) { rotationRef.current = { x: nextX, y: nextY }; applyTransform(nextX, nextY); }
          lastMove = { x: event.clientX, y: event.clientY, t: performance.now() };
        };
        const onPointerUp = (event) => {
          window.removeEventListener('pointermove', onPointerMove);
          draggingRef.current = false;
          let isTap = false;
          if (startPosRef.current) {
            const dx = event.clientX - startPosRef.current.x; const dy = event.clientY - startPosRef.current.y;
            const TAP_THRESH_PX = pointerTypeRef.current === 'touch' ? 10 : 6; isTap = (dx*dx + dy*dy) <= TAP_THRESH_PX*TAP_THRESH_PX;
          }
          // Velocity estimate
          let vx = 0, vy = 0;
          if (startPosRef.current && lastMove.t) {
            const dt = Math.max(1, performance.now() - lastMove.t);
            vx = (event.clientX - lastMove.x) / dt; vy = (event.clientY - lastMove.y) / dt;
            vx = vx * 0.6; vy = vy * 0.6;
          }
          if (!isTap && (Math.abs(vx) > 0.005 || Math.abs(vy) > 0.005)) startInertia(vx, vy);
          cancelTapRef.current = !isTap;
          if (isTap && tapTargetRef.current && !focusedElRef.current) openItemFromElement(tapTargetRef.current);
          tapTargetRef.current = null;
          if (cancelTapRef.current) setTimeout(() => (cancelTapRef.current = false), 120);
          if (movedRef.current) lastDragEndAt.current = performance.now();
          movedRef.current = false;
          if (pointerTypeRef.current === 'touch') unlockScroll();
          startPosRef.current = null;
        };
        el.addEventListener('pointerdown', onPointerDown, { passive: false });
        return () => { el.removeEventListener('pointerdown', onPointerDown); window.removeEventListener('pointermove', onPointerMove); };
      }, [dragSensitivity, maxVerticalRotationDeg, lockScroll, unlockScroll, startInertia, applyTransform]);

      useEffect(() => {
        const scrim = scrimRef.current; if (!scrim) return;
        const close = () => {
          if (performance.now() - openStartedAtRef.current < 250) return;
          const el = focusedElRef.current; if (!el) return; const parent = el.parentElement;
          const overlay = viewerRef.current?.querySelector('.enlarge'); if (!overlay) return;
          const refDiv = parent.querySelector('.item__image--reference');
          const originalPos = originalTilePositionRef.current;
          if (!originalPos) {
            overlay.remove(); if (refDiv) refDiv.remove(); parent.style.setProperty('--rot-y-delta', `0deg`); parent.style.setProperty('--rot-x-delta', `0deg`);
            el.style.visibility=''; el.style.zIndex=0; focusedElRef.current=null; rootRef.current?.removeAttribute('data-enlarging'); openingRef.current=false; return;
          }
          const currentRect = overlay.getBoundingClientRect(); const rootRect = rootRef.current.getBoundingClientRect();
          const originalPosRelativeToRoot = { left: originalPos.left - rootRect.left, top: originalPos.top - rootRect.top, width: originalPos.width, height: originalPos.height };
          const overlayRelativeToRoot = { left: currentRect.left - rootRect.left, top: currentRect.top - rootRect.top, width: currentRect.width, height: currentRect.height };
          const animatingOverlay = document.createElement('div'); animatingOverlay.className = 'enlarge-closing';
          animatingOverlay.style.cssText = `position:absolute;left:${overlayRelativeToRoot.left}px;top:${overlayRelativeToRoot.top}px;width:${overlayRelativeToRoot.width}px;height:${overlayRelativeToRoot.height}px;z-index:9999;border-radius:${openedImageBorderRadius};overflow:hidden;box-shadow:0 10px 30px rgba(0,0,0,.35);transition:all ${enlargeTransitionMs}ms ease-out;pointer-events:none;margin:0;transform:none;filter:${grayscale ? 'grayscale(1)' : 'none'};`;
          const originalImg = overlay.querySelector('img'); if (originalImg) { const img = originalImg.cloneNode(); img.style.cssText='width:100%;height:100%;object-fit:cover;'; animatingOverlay.appendChild(img); }
          overlay.remove(); rootRef.current.appendChild(animatingOverlay); void animatingOverlay.getBoundingClientRect();
          requestAnimationFrame(()=>{ animatingOverlay.style.left = originalPosRelativeToRoot.left+'px'; animatingOverlay.style.top = originalPosRelativeToRoot.top+'px'; animatingOverlay.style.width = originalPosRelativeToRoot.width+'px'; animatingOverlay.style.height = originalPosRelativeToRoot.height+'px'; animatingOverlay.style.opacity='0'; });
          const cleanup = () => {
            animatingOverlay.remove(); originalTilePositionRef.current = null; if (refDiv) refDiv.remove(); parent.style.transition='none'; el.style.transition='none'; parent.style.setProperty('--rot-y-delta', `0deg`); parent.style.setProperty('--rot-x-delta', `0deg`);
            requestAnimationFrame(()=>{ el.style.visibility=''; el.style.opacity='0'; el.style.zIndex=0; focusedElRef.current=null; rootRef.current?.removeAttribute('data-enlarging'); requestAnimationFrame(()=>{ parent.style.transition=''; el.style.transition='opacity 300ms ease-out'; requestAnimationFrame(()=>{ el.style.opacity='1'; setTimeout(()=>{ el.style.transition=''; el.style.opacity=''; openingRef.current=false; if (!draggingRef.current && rootRef.current?.getAttribute('data-enlarging') !== 'true') document.body.classList.remove('dg-scroll-lock'); }, 300); }); }); });
          };
          animatingOverlay.addEventListener('transitionend', cleanup, { once: true });
        };
        scrim.addEventListener('click', close);
        const onKey = e => { if (e.key === 'Escape') close(); };
        window.addEventListener('keydown', onKey);
        return () => { scrim.removeEventListener('click', close); window.removeEventListener('keydown', onKey); };
      }, [enlargeTransitionMs, openedImageBorderRadius, grayscale]);

      const openItemFromElement = (el) => {
        if (!el || cancelTapRef.current) return; if (openingRef.current) return; openingRef.current = true; openStartedAtRef.current = performance.now(); lockScroll();
        const parent = el.parentElement; focusedElRef.current = el; el.setAttribute('data-focused', 'true');
        const offsetX = getDataNumber(parent, 'offsetX', 0); const offsetY = getDataNumber(parent, 'offsetY', 0); const sizeX = getDataNumber(parent, 'sizeX', 2); const sizeY = getDataNumber(parent, 'sizeY', 2);
        const parentRot = computeItemBaseRotation(offsetX, offsetY, sizeX, sizeY, segments); const parentY = normalizeAngle(parentRot.rotateY); const globalY = normalizeAngle(rotationRef.current.y);
        let rotY = -(parentY + globalY) % 360; if (rotY < -180) rotY += 360; const rotX = -parentRot.rotateX - rotationRef.current.x;
        parent.style.setProperty('--rot-y-delta', `${rotY}deg`); parent.style.setProperty('--rot-x-delta', `${rotX}deg`);
        const refDiv = document.createElement('div'); refDiv.className = 'item__image item__image--reference opacity-0'; refDiv.style.transform = `rotateX(${-parentRot.rotateX}deg) rotateY(${-parentRot.rotateY}deg)`; parent.appendChild(refDiv);
        const tileR = refDiv.getBoundingClientRect(); const mainR = mainRef.current.getBoundingClientRect(); const frameR = frameRef.current.getBoundingClientRect();
        originalTilePositionRef.current = { left: tileR.left, top: tileR.top, width: tileR.width, height: tileR.height };
        el.style.visibility = 'hidden'; el.style.zIndex = 0;
        const overlay = document.createElement('div'); overlay.className = 'enlarge'; overlay.style.position = 'absolute'; overlay.style.left = (frameR.left - mainR.left) + 'px'; overlay.style.top = (frameR.top - mainR.top) + 'px'; overlay.style.width = frameR.width + 'px'; overlay.style.height = frameR.height + 'px'; overlay.style.opacity = '0'; overlay.style.zIndex = '30'; overlay.style.willChange = 'transform, opacity'; overlay.style.transformOrigin = 'top left'; overlay.style.transition = `transform ${enlargeTransitionMs}ms ease, opacity ${enlargeTransitionMs}ms ease`; overlay.style.borderRadius = openedImageBorderRadius; overlay.style.overflow = 'hidden'; overlay.style.boxShadow = '0 10px 30px rgba(0,0,0,.35)';
        const rawSrc = parent.dataset.src || el.querySelector('img')?.src || ''; const rawAlt = parent.dataset.alt || el.querySelector('img')?.alt || '';
        const img = document.createElement('img'); img.src = rawSrc; img.alt = rawAlt; img.style.width = '100%'; img.style.height = '100%'; img.style.objectFit = 'cover'; img.style.filter = grayscale ? 'grayscale(1)' : 'none'; overlay.appendChild(img); viewerRef.current.appendChild(overlay);
        const tx0 = tileR.left - frameR.left; const ty0 = tileR.top - frameR.top; const sx0 = tileR.width / frameR.width; const sy0 = tileR.height / frameR.height; overlay.style.transform = `translate(${tx0}px, ${ty0}px) scale(${sx0}, ${sy0})`;
        requestAnimationFrame(() => { overlay.style.opacity = '1'; overlay.style.transform = 'translate(0px, 0px) scale(1, 1)'; rootRef.current?.setAttribute('data-enlarging', 'true'); });
        // Always size to natural image aspect ratio (or custom if provided)
        const onFirstEnd = ev => {
          if (ev.propertyName !== 'transform') return; overlay.removeEventListener('transitionend', onFirstEnd);
          const prevTransition = overlay.style.transition; overlay.style.transition = 'none';
          let targetW, targetH;
          if (openedImageWidth || openedImageHeight) {
            // Respect custom sizes when explicitly provided
            targetW = openedImageWidth ? (typeof openedImageWidth === 'number' ? `${openedImageWidth}px` : openedImageWidth) : `${frameR.width}px`;
            targetH = openedImageHeight ? (typeof openedImageHeight === 'number' ? `${openedImageHeight}px` : openedImageHeight) : `${frameR.height}px`;
          } else {
            // Use natural image dimensions. On desktop, make it 50% larger than the fit size.
            // On mobile (<=900px), keep default fit size. Always cap to viewport bounds.
            const iw = img.naturalWidth || frameR.width;
            const ih = img.naturalHeight || frameR.height;
            const fitScale = Math.min(frameR.width / iw, frameR.height / ih);
            const viewportScaleCap = Math.min(mainR.width / iw, mainR.height / ih);
            const isMobile = window.matchMedia && window.matchMedia('(max-width: 900px)').matches;
            const desiredScale = isMobile ? fitScale : fitScale * 1.5;
            const targetScale = Math.min(desiredScale, viewportScaleCap);
            targetW = `${Math.round(iw * targetScale)}px`;
            targetH = `${Math.round(ih * targetScale)}px`;
          }
          // Measure target box
          overlay.style.width = targetW; overlay.style.height = targetH;
          const newRect = overlay.getBoundingClientRect();
          // Reset to original then animate
          overlay.style.width = frameR.width + 'px'; overlay.style.height = frameR.height + 'px'; void overlay.offsetWidth;
          overlay.style.transition = `left ${enlargeTransitionMs}ms ease, top ${enlargeTransitionMs}ms ease, width ${enlargeTransitionMs}ms ease, height ${enlargeTransitionMs}ms ease`;
          const centeredLeft = frameR.left - mainR.left + (frameR.width - newRect.width) / 2;
          const centeredTop = frameR.top - mainR.top + (frameR.height - newRect.height) / 2;
          requestAnimationFrame(() => {
            overlay.style.left = `${centeredLeft}px`;
            overlay.style.top = `${centeredTop}px`;
            overlay.style.width = targetW;
            overlay.style.height = targetH;
          });
          const cleanupSecond = () => { overlay.removeEventListener('transitionend', cleanupSecond); overlay.style.transition = prevTransition; };
          overlay.addEventListener('transitionend', cleanupSecond, { once: true });
        };
        overlay.addEventListener('transitionend', onFirstEnd);
      };

      useEffect(() => { return () => { document.body.classList.remove('dg-scroll-lock'); }; }, []);

      const cssStyles = `
        .sphere-root { --radius: 520px; --viewer-pad: 72px; --circ: calc(var(--radius) * 3.14); --rot-y: calc((360deg / var(--segments-x)) / 2); --rot-x: calc((360deg / var(--segments-y)) / 2); --item-width: calc(var(--circ) / var(--segments-x)); --item-height: calc(var(--circ) / var(--segments-y)); }
        .sphere-root * { box-sizing: border-box; }
        .sphere, .sphere-item, .item__image { transform-style: preserve-3d; }
        .stage { width: 100%; height: 100%; display: grid; place-items: center; position: absolute; inset: 0; margin: auto; perspective: calc(var(--radius) * 2); perspective-origin: 50% 50%; }
        .sphere { transform: translateZ(calc(var(--radius) * -1)); will-change: transform; position: absolute; }
        .sphere-item { width: calc(var(--item-width) * var(--item-size-x)); height: calc(var(--item-height) * var(--item-size-y)); position: absolute; top: -999px; bottom: -999px; left: -999px; right: -999px; margin: auto; transform-origin: 50% 50%; backface-visibility: hidden; transition: transform 300ms; transform: rotateY(calc(var(--rot-y) * (var(--offset-x) + ((var(--item-size-x) - 1) / 2)) + var(--rot-y-delta, 0deg))) rotateX(calc(var(--rot-x) * (var(--offset-y) - ((var(--item-size-y) - 1) / 2)) + var(--rot-x-delta, 0deg))) translateZ(var(--radius)); }
        .sphere-root[data-enlarging="true"] .scrim { opacity: 1 !important; pointer-events: all !important; }
        .item__image { position: absolute; inset: 10px; border-radius: var(--tile-radius, 12px); overflow: hidden; cursor: pointer; backface-visibility: hidden; -webkit-backface-visibility: hidden; transition: transform 300ms; pointer-events: auto; -webkit-transform: translateZ(0); transform: translateZ(0); }
        .item__image--reference { position: absolute; inset: 10px; pointer-events: none; }
      `;

      return (
        <>
          <style dangerouslySetInnerHTML={{ __html: cssStyles }} />
          <div ref={rootRef} className="sphere-root relative w-full h-full" style={{ ['--segments-x']: segments, ['--segments-y']: segments }}>
            <main ref={mainRef} className="absolute inset-0 grid place-items-center overflow-hidden select-none bg-transparent" style={{ touchAction: 'none', WebkitUserSelect: 'none' }}>
              <div className="stage">
                <div ref={sphereRef} className="sphere">
                  {items.map((it, i) => (
                    <div key={`${it.x},${it.y},${i}`} className="sphere-item absolute m-auto" data-src={it.src} data-alt={it.alt} data-offset-x={it.x} data-offset-y={it.y} data-size-x={it.sizeX} data-size-y={it.sizeY} style={{ ['--offset-x']: it.x, ['--offset-y']: it.y, ['--item-size-x']: it.sizeX, ['--item-size-y']: it.sizeY, top: '-999px', bottom: '-999px', left: '-999px', right: '-999px' }}>
                      <div className="item__image absolute block overflow-hidden cursor-pointer bg-gray-200 transition-transform duration-300" role="button" tabIndex={0} aria-label={it.alt || 'Open image'} onClick={e => { if (performance.now() - lastDragEndAt.current < 80) return; openItemFromElement(e.currentTarget); }} onTouchEnd={e => { if (performance.now() - lastDragEndAt.current < 80) return; openItemFromElement(e.currentTarget); }} style={{ inset: '10px', borderRadius: `var(--tile-radius, 30px)`, backfaceVisibility: 'hidden' }}>
                        <img src={it.src} draggable={false} alt={it.alt} className="w-full h-full object-cover pointer-events-none" style={{ backfaceVisibility: 'hidden', filter: `var(--image-filter, grayscale(1))` }} />
                      </div>
                    </div>
                  ))}
                </div>
              </div>

              <div className="absolute inset-0 m-auto z-[3] pointer-events-none" style={{ backgroundImage: `radial-gradient(rgba(235, 235, 235, 0) 65%, var(--overlay-blur-color, #060010) 100%)` }} />
              <div className="absolute inset-0 m-auto z-[3] pointer-events-none" style={{ WebkitMaskImage: `radial-gradient(rgba(235, 235, 235, 0) 70%, var(--overlay-blur-color, #060010) 90%)`, maskImage: `radial-gradient(rgba(235, 235, 235, 0) 70%, var(--overlay-blur-color, #060010) 90%)`, backdropFilter: 'blur(3px)' }} />
              <div className="absolute left-0 right-0 top-0 h-[120px] z-[5] pointer-events-none rotate-180" style={{ background: `linear-gradient(to bottom, transparent, var(--overlay-blur-color, #060010))` }} />
              <div className="absolute left-0 right-0 bottom-0 h-[120px] z-[5] pointer-events-none" style={{ background: `linear-gradient(to bottom, transparent, var(--overlay-blur-color, #060010))` }} />

              <div ref={viewerRef} className="absolute inset-0 z-20 pointer-events-none flex items-center justify-center" style={{ padding: 'var(--viewer-pad)' }}>
                <div ref={scrimRef} className="scrim absolute inset-0 z-10 pointer-events-none opacity-0 transition-opacity duration-500" style={{ background: 'rgba(0, 0, 0, 0.4)', backdropFilter: 'blur(3px)' }} />
                <div ref={frameRef} className="viewer-frame h-full aspect-square flex" style={{ borderRadius: `var(--enlarge-radius, 30px)` }} />
              </div>
            </main>
          </div>
        </>
      );
    }

    function App() {
      return (
        <div style={{ width: '100%', height: '100%' }}>
          <DomeGallery
            fit={0.8}
            minRadius={600}
            maxVerticalRotationDeg={20}
            segments={34}
            dragDampening={2}
            grayscale={false}
          />
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>

  <script>
    // Intersection Observer for scroll animations (match index)
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          entry.target.classList.add('visible');
          observer.unobserve(entry.target);
        }
      });
    }, { threshold: 0.1 });
    document.querySelectorAll('[data-scroll]').forEach((el) => observer.observe(el));
  </script>

  <script>
    // Variable Proximity effect (vanilla JS) for footer headline (match index)
    (function(){
      const container = document.getElementById('vp-footer-container');
      const headline = document.getElementById('vp-footer-headline');
      if (!container || !headline) return;

      const label = (headline.textContent || '').trim();
      if (!label) return;

      // Config
      const radius = 100; // px
      const falloff = 'linear'; // 'linear' | 'exponential' | 'gaussian'
      const fromSettings = "'wght' 400, 'opsz' 9";
      const toSettings = "'wght' 1000, 'opsz' 40";

      function parseSettings(str){
        const map = new Map();
        str.split(',').map(s=>s.trim()).forEach(s=>{
          if (!s) return;
          const parts = s.split(/\s+/);
          const axis = parts[0] ? parts[0].replace(/["']/g,'') : '';
          const value = parts[1] ? parseFloat(parts[1]) : NaN;
          if (axis && !Number.isNaN(value)) map.set(axis, value);
        });
        return map;
      }
      const fromMap = parseSettings(fromSettings);
      const toMap = parseSettings(toSettings);
      const parsed = [];
      fromMap.forEach((fromValue, axis)=>{
        const toValue = toMap.has(axis) ? toMap.get(axis) : fromValue;
        parsed.push({ axis, fromValue, toValue });
      });

      // Split headline text into word/letter spans
      const words = label.split(' ');
      headline.textContent = '';
      words.forEach((word, wi)=>{
        const w = document.createElement('span');
        w.className = 'vp-word';
        for (let i=0;i<word.length;i++){
          const l = document.createElement('span');
          l.className = 'vp-letter';
          l.textContent = word[i];
          l.style.fontVariationSettings = fromSettings;
          w.appendChild(l);
        }
        headline.appendChild(w);
        if (wi < words.length - 1) headline.appendChild(document.createTextNode(' '));
      });

      const letters = Array.from(headline.querySelectorAll('.vp-letter'));
      const mouse = { x: 0, y: 0 };
      const last = { x: null, y: null };

      function falloffValue(distance){
        const norm = Math.min(Math.max(1 - distance / radius, 0), 1);
        if (falloff === 'exponential') return norm * norm;
        if (falloff === 'gaussian') return Math.exp(-((distance / (radius / 2)) ** 2) / 2);
        return norm; // linear
      }

      function onMove(clientX, clientY){
        const rect = container.getBoundingClientRect();
        mouse.x = clientX - rect.left;
        mouse.y = clientY - rect.top;
      }

      window.addEventListener('mousemove', (e)=> onMove(e.clientX, e.clientY), { passive: true });
      window.addEventListener('touchmove', (e)=> {
        const t = e.touches && e.touches[0];
        if (t) onMove(t.clientX, t.clientY);
      }, { passive: true });

      function loop(){
        if (last.x !== mouse.x || last.y !== mouse.y){
          last.x = mouse.x; last.y = mouse.y;
          const cr = container.getBoundingClientRect();
          for (const el of letters){
            const r = el.getBoundingClientRect();
            const cx = r.left + r.width / 2 - cr.left;
            const cy = r.top + r.height / 2 - cr.top;
            const distance = Math.hypot(mouse.x - cx, mouse.y - cy);
            if (distance >= radius){
              el.style.fontVariationSettings = fromSettings;
            } else {
              const f = falloffValue(distance);
              const settings = parsed.map(({axis, fromValue, toValue})=>{
                const v = fromValue + (toValue - fromValue) * f;
                return `'${axis}' ${v}`;
              }).join(', ');
              el.style.fontVariationSettings = settings;
            }
          }
        }
        requestAnimationFrame(loop);
      }
      requestAnimationFrame(loop);
    })();
  </script>
</body>
</html>
